Below you will find a variety of important rules spanning:

- the dev_workflow
- the .windsurfrules document self-improvement workflow
- the template to follow when modifying or adding new sections/rules to this document.

---

## DEV_WORKFLOW

description: Guide for using LM-Tasker MCP server and CLI to manage task-driven development workflows globs: **/\*
filesToApplyRule: **/\* alwaysApply: true

---

- **Primary Interaction: MCP Server vs. CLI**

  - **MCP Server (Recommended for Integrated Tools)**:

    - For AI agents and integrated development environments (like Windsurf), interacting via the **MCP server is the
      preferred method**
    - The MCP server exposes LM-Tasker functionality through a set of tools (e.g., `get_tasks`, `add_subtask`,
      `update_task`)
    - This method offers better performance, structured data exchange, and richer error handling compared to CLI parsing
    - **Restart the MCP server** if core logic in `scripts/modules` or MCP tool/direct function definitions change
    - MCP tools provide structured JSON responses ideal for programmatic use

  - **`task-master` CLI (For Users & Fallback)**:
    - The global `task-master` command provides a user-friendly interface for direct terminal interaction
    - It can serve as a fallback if the MCP server is inaccessible or a specific function isn't exposed via MCP
    - Install globally with `npm install -g task-master-ai` or use locally via `npx task-master-ai ...`
    - The CLI commands often mirror the MCP tools (e.g., `task-master list` corresponds to `get_tasks`)

- **MCP Tools Overview**

  - **Project Setup**: `initialize_project`, `parse_prd`
  - **Task Viewing**: `get_tasks`, `get_task`, `next_task`
  - **Task Management**: `add_task`, `update_task`, `update_subtask`, `set_task_status`
  - **Task Structure**: `add_subtask`, `remove_task`, `clear_subtasks`, `move_task`
  - **Dependencies**: `add_dependency`, `remove_dependency`, `validate_dependencies`, `fix_dependencies`
  - **File Generation**: `generate`
  - **Configuration**: `models`

- **Development Workflow Process**

  - Start new projects by running `initialize_project` MCP tool / `task-master init` to set up project structure
  - Parse requirements using `parse_prd` MCP tool / `task-master parse-prd --input='<prd-file.txt>'` to generate initial
    tasks.json
  - Begin coding sessions with `get_tasks` MCP tool / `task-master list` to see current tasks, status, and IDs
  - Determine the next task using `next_task` MCP tool / `task-master next`
  - View specific task details using `get_task` MCP tool / `task-master show <id>` to understand implementation
    requirements
  - Break down complex tasks using `add_subtask` MCP tool / `task-master add-subtask` with appropriate details
  - Clear existing subtasks if needed using `clear_subtasks` MCP tool / `task-master clear-subtasks --id=<id>` before
    regenerating
  - Implement code following task details, dependencies, and project standards
  - Verify tasks according to test strategies before marking as complete
  - Mark completed tasks with `set_task_status` MCP tool / `task-master set-status --id=<id> --status=done`
  - Update dependent tasks when implementation differs using `update` or `update_task` MCP tools / `task-master update`
    commands
  - Generate task files with `generate` MCP tool / `task-master generate` after updating tasks.json
  - Maintain valid dependency structure with `validate_dependencies` and `fix_dependencies` MCP tools / corresponding
    CLI commands
  - Respect dependency chains and task priorities when selecting work
  - Report progress regularly using `get_tasks` MCP tool / `task-master list`

- **Task Breakdown Process**

  - Use `add_subtask` MCP tool / `task-master add-subtask` to manually break down complex tasks
  - Provide clear subtask details through the tool parameters or CLI flags
  - Specify prerequisite subtasks using dependency parameters
  - Review and adjust generated subtasks as necessary
  - If subtasks need regeneration, clear them first with `clear_subtasks` MCP tool / CLI command

- **Implementation Drift Handling**

  - When implementation differs significantly from planned approach
  - When future tasks need modification due to current implementation choices
  - When new dependencies or requirements emerge
  - Use `update_task` MCP tool / `task-master update-task --id=<futureTaskId>` (manual updates only) to update tasks
  - Use `update_task` MCP tool / `task-master update-task --id=<id>` (manual updates only) for single task updates

- **Task Status Management**

  - Use 'pending' for tasks ready to be worked on
  - Use 'done' for completed and verified tasks
  - Use 'in-progress' for tasks currently being worked on
  - Use 'deferred' for postponed tasks
  - Add custom status values as needed for project-specific workflows

- **Task File Format Reference**

  ```
  # Task ID: <id>
  # Title: <title>
  # Status: <status>
  # Dependencies: <comma-separated list of dependency IDs>
  # Priority: <priority>
  # Description: <brief description>
  # Details:
  <detailed implementation notes>

  # Test Strategy:
  <verification approach>
  ```

- **MCP Tool Reference: parse_prd**

  - MCP Tool: `parse_prd`
  - CLI Equivalent: `task-master parse-prd --input=<prd-file.txt>`
  - Description: Parses a PRD document and generates a tasks.json file with structured tasks
  - Key Parameters:
    - `input`: Path to the PRD text file
    - `output`: Output path for tasks.json (default: tasks/tasks.json)
    - `numTasks`: Approximate number of top-level tasks to generate
    - `force`: Overwrite existing tasks.json without confirmation
  - Example MCP: Use `parse_prd` tool with input parameter
  - Example CLI: `task-master parse-prd --input=requirements.txt`
  - Notes: Will overwrite existing tasks.json file. Use with caution. AI-powered tool that may take time to complete.

- **MCP Tool Reference: update**

  - MCP Tool: `update`
  - CLI Equivalent: `task-master update-task --id=<id>` (manual updates only)
  - Description: Updates tasks with ID >= specified ID based on the provided prompt
  - Key Parameters:
    - `from`: Task ID from which to start updating (required)
    - `prompt`: Explanation of changes or new context (required)
    - `research`: Enable research-backed updates
  - Example MCP: Use `update_task` tool with id parameter (manual updates only)
  - Example CLI:
    `task-master update-task --id=4 --title="Use Express Framework" --description="Switch from Fastify to Express"`
  - Notes: Only updates tasks not marked as 'done'. AI-powered tool that may take time to complete.

- **MCP Tool Reference: generate**

  - MCP Tool: `generate`
  - CLI Equivalent: `task-master generate`
  - Description: Generates individual task files in tasks/ directory based on tasks.json
  - Key Parameters:
    - `file`: Use alternative tasks.json file (default: tasks/tasks.json)
    - `output`: Output directory (default: tasks)
  - Example MCP: Use `generate` tool
  - Example CLI: `task-master generate`
  - Notes: Overwrites existing task files. Creates tasks/ directory if needed.

- **MCP Tool Reference: set_task_status**

  - MCP Tool: `set_task_status`
  - CLI Equivalent: `task-master set-status --id=<id> --status=<status>`
  - Description: Updates the status of a specific task in tasks.json
  - Key Parameters:
    - `id`: ID of the task to update (required)
    - `status`: New status value (required)
  - Example MCP: Use `set_task_status` tool with id and status parameters
  - Example CLI: `task-master set-status --id=3 --status=done`
  - Notes: Common values are 'done', 'pending', 'in-progress', and 'deferred', but any string is accepted.

- **MCP Tool Reference: get_tasks**

  - MCP Tool: `get_tasks`
  - CLI Equivalent: `task-master list`
  - Description: Lists all tasks in tasks.json with IDs, titles, and status
  - Key Parameters:
    - `status`: Filter by status
    - `withSubtasks`: Show subtasks for each task
    - `file`: Use alternative tasks.json file (default: tasks/tasks.json)
  - Example MCP: Use `get_tasks` tool
  - Example CLI: `task-master list`
  - Notes: Provides quick overview of project progress. Use at start of sessions.

- **MCP Tool Reference: clear_subtasks**

  - MCP Tool: `clear_subtasks`
  - CLI Equivalent: `task-master clear-subtasks --id=<id>`
  - Description: Removes subtasks from specified tasks to allow regeneration
  - Key Parameters:
    - `id`: ID or comma-separated IDs of tasks to clear subtasks from
    - `all`: Clear subtasks from all tasks
  - Example MCP: Use `clear_subtasks` tool with id parameter
  - Example CLI: `task-master clear-subtasks --id=3`
  - Notes: Task files are automatically regenerated after clearing subtasks

- **Task Structure Fields**

  - **id**: Unique identifier for the task (Example: `1`, `1.1`)
  - **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
  - **description**: Concise summary of what the task involves (Example:
    `"Create a new repository, set up initial structure."`)
  - **status**: Current state of the task (Example: `"pending"`, `"done"`, `"in-progress"`, `"deferred"`)
  - **dependencies**: IDs of prerequisite tasks (Example: `[1, 2.1]`)
    - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
    - This helps quickly identify which prerequisite tasks are blocking work
  - **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
  - **details**: In-depth implementation instructions (Example:
    `"Use GitHub client ID/secret, handle callback, set session token."`)
  - **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
  - **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)

- **Configuration Management (Updated)**

  - **`.lmtaskerconfig` File (Primary)**:

    - Located in the project root directory
    - Stores most configuration settings: AI model selections (main, research, fallback), parameters (max tokens,
      temperature), logging level, default subtasks/priority, project name, etc.
    - **Managed via `models` MCP tool or `task-master models --setup` command**
    - **View/Set specific models via `models` MCP tool or `task-master models` command**
    - Created automatically when you run model configuration for the first time

  - **Environment Variables (`.env` / `mcp.json`)**:

    - Used **only** for sensitive API keys and specific endpoint URLs
    - Place API keys in a `.env` file in the project root for CLI usage
    - For MCP/Windsurf integration, configure these keys in the `env` section of MCP configuration
    - Available keys: `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, `PERPLEXITY_API_KEY`, `GOOGLE_API_KEY`, `MISTRAL_API_KEY`,
      etc.

  - **Important**: Non-API key settings (like model selections, `MAX_TOKENS`, `TASKMASTER_LOG_LEVEL`) are **no longer
    configured via environment variables**. Use the `models` MCP tool or `task-master models` command.
  - **If AI commands FAIL in MCP** verify that the API key for the selected provider is present in the MCP configuration
    environment section.
  - **If AI commands FAIL in CLI** verify that the API key for the selected provider is present in the `.env` file in
    the root of the project.

- **Determining the Next Task**

  - Use `next_task` MCP tool / `task-master next` to show the next task to work on
  - The tool identifies tasks with all dependencies satisfied
  - Tasks are prioritized by priority level, dependency count, and ID
  - The tool shows comprehensive task information including:
    - Basic task details and description
    - Implementation details
    - Subtasks (if they exist)
    - Contextual suggested actions
  - Recommended before starting any new development work
  - Respects your project's dependency structure
  - Ensures tasks are completed in the appropriate sequence
  - Provides ready-to-use commands for common task actions

- **Viewing Specific Task Details**

  - Use `get_task` MCP tool / `task-master show <id>` to view a specific task
  - Use dot notation for subtasks: `get_task` with id "1.2" (shows subtask 2 of task 1)
  - Displays comprehensive information similar to the next command, but for a specific task
  - For parent tasks, shows all subtasks and their current status
  - For subtasks, shows parent task information and relationship
  - Provides contextual suggested actions appropriate for the specific task
  - Useful for examining task details before implementation or checking status

- **Managing Task Dependencies**

  - Use `add_dependency` MCP tool / `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency
  - Use `remove_dependency` MCP tool / `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a
    dependency
  - The system prevents circular dependencies and duplicate dependency entries
  - Dependencies are checked for existence before being added or removed
  - Task files are automatically regenerated after dependency changes
  - Dependencies are visualized with status indicators in task listings and files

- **MCP Tool Reference: add_dependency**

  - MCP Tool: `add_dependency`
  - CLI Equivalent: `task-master add-dependency --id=<id> --depends-on=<id>`
  - Description: Adds a dependency relationship between two tasks
  - Key Parameters:
    - `id`: ID of task that will depend on another task (required)
    - `dependsOn`: ID of task that will become a dependency (required)
  - Example MCP: Use `add_dependency` tool with id and dependsOn parameters
  - Example CLI: `task-master add-dependency --id=22 --depends-on=21`
  - Notes: Prevents circular dependencies and duplicates; updates task files automatically

- **MCP Tool Reference: remove_dependency**

  - MCP Tool: `remove_dependency`
  - CLI Equivalent: `task-master remove-dependency --id=<id> --depends-on=<id>`
  - Description: Removes a dependency relationship between two tasks
  - Key Parameters:
    - `id`: ID of task to remove dependency from (required)
    - `dependsOn`: ID of task to remove as a dependency (required)
  - Example MCP: Use `remove_dependency` tool with id and dependsOn parameters
  - Example CLI: `task-master remove-dependency --id=22 --depends-on=21`
  - Notes: Checks if dependency actually exists; updates task files automatically

- **MCP Tool Reference: validate_dependencies**

  - MCP Tool: `validate_dependencies`
  - CLI Equivalent: `task-master validate-dependencies`
  - Description: Checks tasks.json for dependency issues without making changes
  - Key Parameters:
    - `file`: Use alternative tasks.json file (default: tasks/tasks.json)
  - Example MCP: Use `validate_dependencies` tool
  - Example CLI: `task-master validate-dependencies`
  - Notes:
    - Identifies circular dependencies between tasks
    - Finds references to non-existent tasks or subtasks
    - Reports self-dependencies (tasks depending on themselves)
    - Provides detailed report without modifying any files

- **MCP Tool Reference: fix_dependencies**

  - MCP Tool: `fix_dependencies`
  - CLI Equivalent: `task-master fix-dependencies`
  - Description: Finds and fixes all invalid dependencies in tasks.json and task files
  - Key Parameters:
    - `file`: Use alternative tasks.json file (default: tasks/tasks.json)
  - Example MCP: Use `fix_dependencies` tool
  - Example CLI: `task-master fix-dependencies`
  - Notes:
    - Removes references to non-existent tasks and subtasks
    - Eliminates self-dependencies (tasks depending on themselves)
    - Regenerates task files with corrected dependencies
    - Provides detailed report of all fixes made

- **MCP Tool Reference: add_task**

  - MCP Tool: `add_task`
  - CLI Equivalent: `task-master add-task [options]`
  - Description: Add a new task to tasks.json using AI
  - Key Parameters:
    - `prompt`: Description of the task to add (required)
    - `dependencies`: Comma-separated list of task IDs this task depends on
    - `priority`: Task priority (high, medium, low) (default: medium)
    - `file`: Path to the tasks file (default: tasks/tasks.json)
  - Example MCP: Use `add_task` tool with title and description parameters
  - Example CLI:
    `task-master add-task --title="User Authentication" --description="Create user authentication using Auth0"`
  - Notes: Uses AI to convert description into structured task with appropriate details. AI-powered tool that may take
    time to complete.

- **MCP Tool Reference: initialize_project**

  - MCP Tool: `initialize_project`
  - CLI Equivalent: `task-master init`
  - Description: Initialize a new project with LM-Tasker structure
  - Key Parameters:
    - `projectRoot`: The root directory for the project (required)
    - `yes`: Skip prompts and use default values
    - `skipInstall`: Skip installing dependencies automatically
    - `addAliases`: Add shell aliases (tm, lmtasker) to shell config file
  - Example MCP: Use `initialize_project` tool with projectRoot parameter
  - Example CLI: `task-master init`
  - Notes:
    - Creates initial project structure with required files
    - Prompts for project settings if not provided
    - Merges with existing files when appropriate
    - Can be used to bootstrap a new LM-Tasker project quickly

- **Code Analysis & Refactoring Techniques**
  - **Top-Level Function Search**
    - Use grep pattern matching to find all exported functions across the codebase
    - Command:
      `grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
    - Benefits:
      - Quickly identify all public API functions without reading implementation details
      - Compare functions between files during refactoring (e.g., monolithic to modular structure)
      - Verify all expected functions exist in refactored modules
      - Identify duplicate functionality or naming conflicts
    - Usage examples:
      - When migrating from `scripts/dev.js` to modular structure: `grep -E "function \w+\(" scripts/dev.js`
      - Check function exports in a directory: `grep -E "export (function|const)" scripts/modules/`
      - Find potential naming conflicts: `grep -E "function (get|set|create|update)\w+\(" -r ./`
    - Variations:
      - Add `-n` flag to include line numbers
      - Add `--include="*.ts"` to filter by file extension
      - Use with `| sort` to alphabetize results
    - Integration with refactoring workflow:
      - Start by mapping all functions in the source file
      - Create target module files based on function grouping
      - Verify all functions were properly migrated
      - Check for any unintentional duplications or omissions

---

## WINDSURF_RULES

description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness. globs:
.windsurfrules filesToApplyRule: .windsurfrules alwaysApply: true

---

The below describes how you should be structuring new rule sections in this document.

- **Required Rule Structure:**

  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **Section References:**

  - Use `ALL_CAPS_SECTION` to reference files
  - Example: `WINDSURF_RULES`

- **Code Examples:**

  - Use language-specific code blocks

  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;

  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**

  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**

  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules

---

## SELF_IMPROVE

description: Guidelines for continuously improving this rules document based on emerging code patterns and best
practices. globs: **/\* filesToApplyRule: **/\* alwaysApply: true

---

- **Rule Improvement Triggers:**

  - New code patterns not covered by existing rules
  - Repeated similar implementations across files
  - Common error patterns that could be prevented
  - New libraries or tools being used consistently
  - Emerging best practices in the codebase

- **Analysis Process:**

  - Compare new code with existing rules
  - Identify patterns that should be standardized
  - Look for references to external documentation
  - Check for consistent error handling patterns
  - Monitor test patterns and coverage

- **Rule Updates:**

  - **Add New Rules When:**

    - A new technology/pattern is used in 3+ files
    - Common bugs could be prevented by a rule
    - Code reviews repeatedly mention the same feedback
    - New security or performance patterns emerge

  - **Modify Existing Rules When:**
    - Better examples exist in the codebase
    - Additional edge cases are discovered
    - Related rules have been updated
    - Implementation details have changed

- **Example Pattern Recognition:**

  ```typescript
  // If you see repeated patterns like:
  const data = await prisma.user.findMany({
    select: { id: true, email: true },
    where: { status: "ACTIVE" },
  });

  // Consider adding a PRISMA section in the .windsurfrules:
  // - Standard select fields
  // - Common where conditions
  // - Performance optimization patterns
  ```

- **Rule Quality Checks:**

  - Rules should be actionable and specific
  - Examples should come from actual code
  - References should be up to date
  - Patterns should be consistently enforced

- **Continuous Improvement:**

  - Monitor code review comments
  - Track common development questions
  - Update rules after major refactors
  - Add links to relevant documentation
  - Cross-reference related rules

- **Rule Deprecation:**

  - Mark outdated patterns as deprecated
  - Remove rules that no longer apply
  - Update references to deprecated rules
  - Document migration paths for old patterns

- **Documentation Updates:**
  - Keep examples synchronized with code
  - Update references to external docs
  - Maintain links between related rules
  - Document breaking changes

Follow WINDSURF_RULES for proper rule formatting and structure of windsurf rule sections.
